title: Using the bokeh.models API
---
summary:

---
pub_date: @todo
---
author: Luke Canavan
---
twitter_handle: canavandl
---
body:

#### text-block ####
text:

-----

## Prior Art

The concept of writing a cookbook-style Bokeh educational guide is inspired
by Tom Augspurger's recent
[Modern Pandas](https://tomaugspurger.github.io/modern-1.html) series. Similar
to Tom's series, this aims be a collection of best practices for writing
idiomatic Bokeh visualization based on personal experience of having written
many such visualizations and being a Bokeh core developer. This first piece
happens to be fairly introductory, so new users of Bokeh are welcome to follow
along. Other good resources for beginners include the
[User Guide](http://bokeh.pydata.org/en/latest/docs/user_guide.html) section
of the Bokeh documentation, x Bryan talk, and y Sarah Bird talk.

## Introduction

Before delving into things, it's helpful to define some Bokeh terminology.
Models represent all the parts of your visualization: plots, data sources,
axes, tools, etc. They are classes that have some defined properties
(i.e. ``Plot`` models have a ``plot_height`` and ``plot_width``), as well as
some associated event handling (i.e. changing the
``Plot.background_fill_color`` property will cause the plot to re-render and
update the background_fill_color).

Models Reference: http://bokeh.pydata.org/en/latest/docs/reference/models.html

Glyphs are a subset of models and represent Bokeh's plotting primitives
- the Lines, Circles and Rects that compose visualizations. You could think
of them as the equivalent to D3's elements.

Glyphs Reference: http://bokeh.pydata.org/en/latest/docs/reference/models/glyphs.html

Bokeh has two main API levels for composing these Models and Glyphs into
full-fledged visualization:
* ``bokeh.plotting`` for mid-level, with reasonable defaults for conciseness
* ``bokeh.models`` for low-level, very explicit development

Additionally, some libraries built on top of Bokeh to offer a even higher
level of abstraction such as [HoloViews](http://holoviews.org/).

There are several valid Bokeh-development patterns, but I find the low-level,
primitives-based bokeh.models API to be ideal for developing custom, bespoke
visualizations. Under the hood, Bokeh generates a JSON blob called a
"scenegraph" that describes the visualization (a ``Document`` in Bokeh) and
that is consumed by the BokehJS client library in order to render an output.
You can view this scenegraph via the ``Document.to_json`` method, thought it's
generally not useful for humans.

#### Todo: add example

However, it's helpful to know that all Bokeh visualizations boil down to a
collection of models and attributes. In order to build up a scenegraph, you
just have to build up a collection of models. There's not any "magic"
beyond that.

Please note, I haven't used Bokeh much in an exploratory
manner, so I don't know how well the below workflow fits. Usually I have as
idea of the shape of my data and what my intended visualization looks like.

-----

## Using the ``bokeh.models.plots.Plot`` object

The core of using the low-level ``bokeh.models`` API is building visualizations
using the ```Plot`` Model. A ``Plot`` object is the foundation onto which any
Bokeh visualization is composed - it holds all of axes, grids, glyphs and
toolbar tools. Additionally, it manages a few Plot-specific properties like
height, width and background color. The
The [documentation](http://bokeh.pydata.org/en/latest/docs/reference/models/plots.html#bokeh.models.plots.Plot)
is a good reference for these.

In order to be rendered, a ``Plot`` object only requires having set it's
``x_range`` and ``y_range`` properties. Outputting this
(using the ``bokeh.io.show`` method, for example) will yield an empty rectangle,
which is exactly what we expect. It's an empty canvas without any axes, glyphs
or tools!

```python
from bokeh.models import Plot, Range1d

plot = Plot(x_range=Range1d(), y_range=Range1d())
```

## TODO add code output

### Defining Ranges: Using a Range1d vs FactorRange vs DataRange1d

There are three range types and it's helpful to pick the right one. The
``Range1d`` model is used when you want to set the start and end values of
your range, regardless of what data is being plotted. For example, I would
use a Range1d when I want a range to span from 0 - 100%, even if my data's
range is from 12 - 94%.

```python
range = Range(start=0, end=100)
```

The FactorRange model is similar to the Range1d model, except that handles
categorical values instead of continuous ones. An example situation to use
a FactorRange is when plotting values by months of the year.

```python
range = FactorRange(factors=["Jan", "Feb", "Mar", "Apr", "May", "Jun"])
```

The ``DataRange1d`` model is used when you want the range to reflect the extent
of your plotted data. For example, Dask.distributed uses Bokeh for its
diagnostic web interface [link](https://distributed.readthedocs.io/en/latest/web.html).
The interface takes advantage of a several DataRange1d models to plot the
progress of computation tasks and CPU/memory usage over time. The DataRange1d
will inspect the min and max of the plotted values and automatically adjust the
visible range accordingly.

```python
range = DataRange1d()
```

One new requirement in Bokeh 0.12.6 is that range models correspond with an
appropriate ``Scale`` model, which maps between screen and data space, on
the same dimension. If you have a misconfigured Range and Scale pair, you'll
raise a validation error.

-----

## Additive development, not subtractive or mutative

In general, I prefer to develop Bokeh visualizations in an additive manner,
where each element or interaction is explicitly inserted. While the end result
is often more verbose, I feel the resulting code is easier to write and read
later.

I think it's best to show a counter-example to demonstrate the situation
I'm hoping to avoid. The core of the bokeh.plotting API is the ``figure``
method, which creates a subclassed instance of Plot with defaults related to
ranges, axes, grids, tools, etc.

```python
from bokeh.plotting import figure

plot = figure()
```

These defaults are very reasonable and many can be modified via arguments to
the ``figure`` method. In my experience however, these defaults often include
models I need to remove or modify and my code starts to look like this:

```python
from bokeh.plotting import figure

plot = figure()

# hide the x and y grids
plot.xgrid.visible = False
plot.ygrid.visible = False

# change x axis defaults
plot.xaxis[0].ticker = BasicTicker(num_desired_ticks=2)
plot.xaxis[0].formatter = NumericalTickFormatter(format="0b")
plot.xaxis[0].min_tick_line_width = 4
plot.xaxis[0].major_tick_line_width = 2
```

At this level of customization, it's easier to explicitly set the property
values via the model initializers and not have created unwanted models in
the first place. The code below generated the same output as above, but reads
more cleanly.

```python
plot = Plot()

x_axis = LinearAxis(
  formatter=NumericalTickFormatter(format="0b"),
  ticker=BasicTicker(num_desired_ticks=2),
  min_tick_line_width=4,
  major_tick_line_width=2)
y_axis = LinearAxis()

plot.add_layout(x_axis, 'below')
plot.add_layout(y_axis, 'left')
```

## Tools

I find I generally only include a single tool with non-default attributes in
finalized visualizations, whether it's a HoverTool with a custom tooltips
or a TapTool that initiates some sort of custom interaction. Therefore, I
prefer to add tools to my visualization in a similarly explicit manner.
Instead of selecting and mutating a tool is added by default in via the
``figure`` method, it's cleaner to manually create then add the tool.

```python

# Don't do this
hover = plot.select_one(HoverTool)
hover.tooltips = custom_tooltips
hover.line_policy = 'nearest'
pan = plot.select_one(PanTool)
pan.dimension = 'x'

# Do this instead
hover_tool = HoverTool(tooltips=custom_tooltips, line_policy='nearest')
pan_tool = PanTool(dimension="x")
plot.add_tools(hover_tool, pan_tool)
```

The ``figure`` method also supports adding tools in this manner or via the
initializer (i.e. ``figure(tools=[hover_tool, pan_tool])), so it may be a good
habit to build.

## Glyphs

Glyphs are added via the ``Plot.add_glyph`` method, which requires creating
a ColumnDataSource instead of optionally creating one implicitly like the
convenience glyphs methods of ``Figure``.

The string keyword argument values are matched up against equally-named columns
in the ColumnDataSource while single values (including special )

## Adding glyphs

```python
source = ColumnDataSource(data=dict(
  x=[5, 10, 15], y=[3, 2, 3], height=[1, 1, 1]
))

plot.add_glyph(
  source,
  Rect(x='x', y='y', width=10, height='height', fill_color='red', line_color='blue'))
```

## Wrap up

Using the bokeh.models interface API trades a little verbosity for extreme
customizability, and an explicit incremental approach to building interactive
visualizations. Refactoring code developed in this manner is straightforward
because it's obvious where elements of the visualization are created and added.
All-in-all, I think it's the way to go.

----
class: default
